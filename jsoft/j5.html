<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html;charset=UTF-8" http-equiv="Content-Type"/>
<link rel="stylesheet" type="text/css" href="../tools/ctut.css"/>
<link type="text/css" rel="stylesheet" href="../tools/style.css"/>
<style type="text/css">@font-face {font-family: SHREE_BAN_OTF_0592;src: local("../tools/SHREE_BAN_OTF_0592"),url(../tools/SHREE0592.woff) format("opentype");</style>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<div id="fb-root"></div>
<script async defer crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v19.0" nonce="Q7jTbrCq"></script>

<script src="../tools/jquery-1.10.2.min.js"></script>

<script>
aha = function(code) {
  window.open("https://rdrr.io/snippets/embed/?code="+code)
}

togglePhoto = function(photoId) {
   var me = document.getElementById("pic_"+photoId)
   if(me.style.display=="block"){
     me.style.display="none";
   }
   else if (me.style.display=="none"){
     me.style.display="block";
   }
}

hideShow = function(lb) {
   var me = document.getElementById(lb)
   if(me.style.display=="block"){
     me.style.display="none";
   }
   else if (me.style.display=="none"){
     me.style.display="block";
   }
}

grabData = function(data){
  return "https://farm"+data.photo.farm+".staticflickr.com/"+data.photo.server+"/"+data.photo.id+"_"+
            data.photo.secret+".jpg"
}

fromFlickr = function(photoId) {

$.getJSON("https://api.flickr.com/services/rest/?method=flickr.photos.getInfo&api_key=23a138c73bdbe1e68601aa7866924e62&user_id=109924623@N07&photo_id="+photoId+"&lang=en-us&format=json&jsoncallback=?",
  function(data) {
    imgURL = grabData(data)
    var l = document.getElementById("lnk_"+photoId)
    l.href = "https://www.flickr.com/photos/109924623@N07/"+photoId
    var i = document.getElementById("pic_"+photoId)
    i.src=imgURL
    i.onload = function() {
      document.getElementById("status_"+photoId).innerHTML="[Image loaded. Click to show/hide.]"
    }
  })
}
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js","color.js"],
    jax: ["input/TeX","output/HTML-CSS"],
    tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]},
    TeX: {
      Macros: {
        h: ["{\\hat #1}",1],
        b: ["{\\overline #1}", 1],
        row: "{\\mathcal R}",
        col: "{\\mathcal C}",
        nul: "{\\mathcal N}"
      }
    }
  });
</script>
<style>
body {
  margin: 0;
  //background: #000;
  //color: #fff;
}


.sticky {
  position: fixed;
  top: 0;
  width: 100%;
  background: #555;
  color: #f1f1f1;
}

.cu {
  background: #ffcccc;
}

.bu {
  background: #ccccff;
}

.scrpt {
  border-left: 5px solid black;
}

.box {
  border: 2px solid black;
  display: inline-block;
}
</style>
<script>
window.onscroll = function() {myFunction()};
window.onload = function() {myInit()};

var header, tphldr;
function myInit() {
  header = document.getElementsByClassName("header");
  tphldr = document.getElementById("topholder");
}

function myFunction() {
  var index = -1
  for(i=0;i<header.length;i++) {
    if (window.pageYOffset > header[i].offsetTop) {
       index = i
    }
    else {
       break
    }
  }

  if(index < 0) 
    tphldr.innerHTML = "";
  else
    tphldr.innerHTML = header[index].innerHTML
}
</script><script type="text/javascript" src="https://arnabc74.github.io/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="file:///home/asu/na/v/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="../tools/htmlwidgets.js"></script>
<link href="../tools/rgl.css" rel="stylesheet"></link>
<script src="../tools/rglClass.src.js"></script>
<script src="../tools/CanvasMatrix.src.js"></script>
<script src="../tools/rglWebGL.js"></script>
</head><body>
<div class="sticky" id="topholder"> </div>
<a href="http://www.isical.ac.in/~arnabc/">[Home]</a>
<h3>Table of contents</h3>
<ul>
<li>
<a href="#Tree handling functions">Tree handling functions</a>
</li>
<li>&nbsp;&nbsp;&nbsp;
<a href="#Structure of trees">Structure of trees</a>
</li>
<li>&nbsp;&nbsp;&nbsp;
<a href="#Accessing items">Accessing items</a>
</li>
<li>&nbsp;&nbsp;&nbsp;
<a href="#Modifying a tree">Modifying a tree</a>
</li>
<li>&nbsp;&nbsp;&nbsp;
<a href="#Combining trees">Combining trees</a>
</li>
<li>&nbsp;&nbsp;&nbsp;
<a href="#The comma family (dyad)">The comma family (dyad)</a>
</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#Appending">Appending</a>
</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#Laminate ">Laminate </a>
</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#Stitch">Stitch</a>
</li>
<li>&nbsp;&nbsp;&nbsp;
<a href="#The comma family (monad)">The comma family (monad)</a>
</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#Ravel ">Ravel </a>
</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#Itemize ">Itemize </a>
</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#Ravel items ">Ravel items </a>
</li>
<li>&nbsp;&nbsp;&nbsp;
<a href="#The semicolon family">The semicolon family</a>
</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#Box-append (link)">Box-append (link)</a>
</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#Raze">Raze</a>
</li>
</ul>
<hr/>
<h1><a
name="Tree handling functions">Tree handling functions</a></h1>
The most important and frequently used functions in J are the
ones that manipulate the tree structure. As these are unique to
J, these are also the ones that will take more time to
digest. 
<p></p>

<h2><a
name="Structure of trees">Structure of trees</a></h2>

<p></p>
A tree in J is always balanced. This allows an easy way to store
it. Just store the leaf nodes, and also the shape. So if you want
to reshape the tree, just change the shape. This is done
using <font color="red"><code>$</code></font> dyad. It considers the tree as a list (not the
inderlying list). If the list has a length different from the
product of the shape values, then the list is replicated
(possibly partially). The same symbol <font color="red"><code>$</code></font> used as a monad
will extract the shape of a tree. The monad <font color="red"><code>#</code></font> returns the
number of items in a tree. If we want to see the
underlying list, then you can use the monad <font color="red"><code>,</code></font>
(mysteriously called ravel). To really change the shape you need
to use <font color="red"><code>m n $ , x</code></font>

<p></p>

<h2><a
name="Accessing items">Accessing items</a></h2>

<p></p>
To access items we use the <font color="red"><code>{</code></font> family.
 get the first
item use the monad <font color="red"><code>{.</code></font>. To get the last item use the
monad <font color="red"><code>{:</code></font>.  To get an item at a specific
position (0-based) use the dyad <font color="red"><code>{</code></font>.
<p></p>
Most often a tree is best considered as a list of items. Such
 lists are sometimes mere packets of a small number of
 items. There is a quick way to unpack such a tree:
<span class="j">
<pre>
'a b c' =: x
</pre>
</span>
This command expects <font color="red"><code>x</code></font> to be a list of 3 items. These
 get stored in the variables <font color="red"><code>a</code></font>, <font color="red"><code>b</code></font> and <font color="red"><code>c</code></font>.
<p></p>

<p></p>
 To get a new tree consisting of all the items
except the first use <font color="red"><code>}.</code></font>. If you want to remove the last
item then use the monad <font color="red"><code>}:</code></font>.
<p></p>

<h2><a
name="Modifying a tree">Modifying a tree</a></h2>

<font color="red"><code>|:</code></font> (monad and dyad) 
applies <font color="red"><code>|.</code></font> (monad and dyad) to the shape.
<p></p>
This effectively permutes the indices always maintaining the
following contract: If $\pi$ denote the permutation, then 
the new entry at $(\pi(i_1),...,\pi(i_k))$ will always
equal the old entry at $(i_1,...,i_k)$.
<p></p>

<p></p>
The dyad <font color="red"><code>|:</code></font> will transpose a matrix.
<p></p>

<h2><a
name="Combining trees">Combining trees</a></h2>
Next we shall discuss three important ways to combine two trees
to produce a bigger tree.
Keeping an analogy in mind might prove helpful here:
<blockquote> When
we work with fractions we often prefer to express them in their
reduced forms. However, when we perform an operation on two
fractions in reduced forms, the immediate result may not be in
reduced form, <i>e.g.</i>, 
$$
\frac 18+\frac 38 = \frac 48.
$$
So we need to do a bit of post-processing (cancellation in this
example) to achieve the reduced form.
</blockquote>
Similarly, J likes to keep its trees balanced (all branches have
same length, and all siblings have same number of children). When
we combine two such trees, the immediate result may not be
balanced. So J performs some post-processing to balance the
tree. It helps to have an idea of what this involves. Basically,
there is only one guiding principle: always pad shorter things to
match longer counterparts. An example will help. Here is an
unbalanced tree:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/unbal.png"></th>
</tr>
<tr>
<th></th>
</tr>
</table>
</center>
The last branch is shorter than the rest, and the second branch
has one less leaf node. To make it balanced J first grows the
short branch until it is as long as the longest branch:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/bal1.png"></th>
</tr>
<tr>
<th></th>
</tr>
</table>
</center>
Now at each level we shall find the maximum number of children,
and pad smaller numbers to the right. We start doing this bottom
up. After the bottom most layer is done, the tree looks like this:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/bal2.png"></th>
</tr>
<tr>
<th></th>
</tr>
</table>
</center>
Next we attack the layer above:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/bal3.png"></th>
</tr>
<tr>
<th></th>
</tr>
</table>
</center>
This process is always done internally.
<p></p>

<h2><a
name="The comma family (dyad)">The comma family (dyad)</a></h2> 

<h3><a
name="Appending">Appending</a></h3>
The <font color="red"><code>,</code></font> dyad appends two trees "side by side":
<p></p>

<center>
<table width="100%">
<tr>
<th><img width="" src="image/app.png"></th>
</tr>
<tr>
<th>The new tree may need to be balanced</th>
</tr>
</table>
</center>

<p></p>

<p></p>
Here is a complete example with balancing.
<p></p>

<center>
<table width="100%">
<tr>
<th><img width="" src="image/append1.png"></th>
</tr>
<tr>
<th>Step 0: The two trees to be appended</th>
</tr>
</table>
</center>
First the trees are combined by merging their root nodes:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/append2.png"></th>
</tr>
<tr>
<th>Step 1: The result of direct appending</th>
</tr>
</table>
</center>
Then the resulting  tree is balanced:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/append3.png"></th>
</tr>
<tr>
<th>Step 2: The final result</th>
</tr>
</table>
</center>
 The simplest case is
of course, where the tree in step 1 is already
balanced. This is what you'll need most of the time (though
often you'll find yourself in the unbalanced situation by
mistake!). There is one situation however, which is not covered
by this: when one of the two trees is just the root node:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/append4.png"></th>
</tr>
<tr>
<th>Step 0: The blue atom to be appended</th>
</tr>
</table>
</center>
 Then
"merging the root nodes" would not produce a tree at all. In
this case, we create a new item of the same shape as the other,
where the atom is <i>replicated in all its leaf nodes</i>:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/append5.png"></th>
</tr>
<tr>
<th>Step 1: The final result</th>
</tr>
</table>
</center>
Intuitively, appending is a way to grow a longer list.
<p></p>

<h3><a
name="Laminate ">Laminate </a></h3>

<font color="red"><code>,:</code></font>
Another natural way to combine two trees is by creating a new
tree with these two trees as items (and then balancing if
needed). This is called lamination, and effected
by <font color="red"><code>,:</code></font>. 
<p></p>

<center>
<table width="100%">
<tr>
<th><img width="" src="image/lam.png"></th>
</tr>
<tr>
<th>The new tree needs to be balanced.</th>
</tr>
</table>
</center>
Here's one complete example with balancing.
<center>
<table width="100%">
<tr>
<th><img width="" src="image/laminate1.png"></th>
</tr>
<tr>
<th>Step 0: the two trees to be
laminated</th>
</tr>
</table>
</center>
The two trees are hung from a common root node.
<center>
<table width="100%">
<tr>
<th><img width="" src="image/laminate2.png"></th>
</tr>
<tr>
<th>Step 1: after combining</th>
</tr>
</table>
</center>
Then we balance the tree:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/laminate3.png"></th>
</tr>
<tr>
<th>Step 2: the final result</th>
</tr>
</table>
</center>
As usual, the most frequently encountered situation is where the
tree in step 1 is already balanced. Intuitively, lamination is
the way to grow a list of lists. 
<p></p>

<h3><a
name="Stitch">Stitch</a></h3>

<font color="red"><code>,.</code></font>
This is yet another way to combine two trees which is not very
intuitive. If we have a list of $x$-values and a
corresponding list of $y$-values, then stitching will
produce a list of $(x,y)$ pairs. More precisely, given two
trees with equal number of items, the corresponding items pairs
are appended. 
<center>
<table width="100%">
<tr>
<th><img width="" src="image/stitch1.png"></th>
</tr>
<tr>
<th>Step 1: two trees to be stitched together</th>
</tr>
</table>
</center>

<center>
<table width="100%">
<tr>
<th><img width="" src="image/stitch2.png"></th>
</tr>
<tr>
<th>Step 2: the final result</th>
</tr>
</table>
</center>
If the numbers of items are not equal, then J
reports a length error.
<p></p>

<h2><a
name="The comma family (monad)">The comma family (monad)</a></h2>

<h3><a
name="Ravel ">Ravel </a></h3>

<font color="red"><code>,</code></font>
Sometimes you need to see the underlying list. This is
called <b>ravel</b>ling, and is effected by the
monad <font color="red"><code>,</code></font>. In terms of trees, it creates a new tree with the
same leaf nodes in the same order, but immediately under the
root. If the original tree is just the root node, then ravel
creates a new root node above it.
<center>
<table width="100%">
<tr>
<th><img width="" src="image/ravel.png"></th>
</tr>
<tr>
<th>Ravelling</th>
</tr>
</table>
</center>

<p></p>

<h3><a
name="Itemize ">Itemize </a></h3>

<font color="red"><code>,:</code></font>
This creates a new tree, with the old tree as its single item. In
other words, it adds a parent to the root node, and that parent
becomes the new root node. A leading 1 is added to the shape.
 <center>
<table width="100%">
<tr>
<th><img width="" src="image/item.png"></th>
</tr>
<tr>
<th>Itemization</th>
</tr>
</table>
</center>
 In
terms of sets it is like converting $x$ to a singleton
set $\{x\}$.
<p></p>

<h3><a
name="Ravel items ">Ravel items </a></h3>

<font color="red"><code>,.</code></font>
This applies ravel to each item separately. Indeed this is the
same as ravelling with rank $-1.$
<p></p>

<h2><a
name="The semicolon family">The semicolon family</a></h2>

<h3><a
name="Box-append (link)">Box-append (link)</a></h3>
The dyad <font color="red"><code>;</code></font> effectively does the same thing as the dyad <font color="red"><code>,</code></font>, but after
boxing. The result is a tree with two leaf nodes under a root,
the  leaf nodes being boxes containing the original
trees. Simple!
<p></p>

<h3><a
name="Raze">Raze</a></h3>
This is the monad <font color="red"><code>;</code></font>. It expects a list of boxes, unboxes
the items and then tries
to append them together. As the items may be
wildly different in shape and type, this may entail a massive amount of recasting
and balancing.   
 <center>
<table width="100%">
<tr>
<th><img width="" src="image/raze.png"></th>
</tr>
<tr>
<th>The new tree may need to be balanced</th>
</tr>
</table>
</center>
Remember that unboxing keeps unboxed things
unaltered. So if the tree were a list of unboxed items, then raze
is just same as appending the items.
<p></p>
<hr/>
<table width="100%" border="0">
<tr>
<td align="left"/>
<td align="right"/>
</tr>
</table>
<hr/></body></html>
