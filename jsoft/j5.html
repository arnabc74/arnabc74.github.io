<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html;charset=UTF-8" http-equiv="Content-Type"/>
<link rel="stylesheet" type="text/css" href="../tools/ctut.css"/>
<link type="text/css" rel="stylesheet" href="../tools/style.css"/>
<style type="text/css">@font-face {font-family: SHREE_BAN_OTF_0592;src: local("../tools/SHREE_BAN_OTF_0592"),url(../tools/SHREE0592.woff) format("opentype");</style>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<script src="../tools/jquery-1.10.2.min.js"></script>

<script>
aha = function(code) {
  window.open("https://rdrr.io/snippets/embed/?code="+code)
}

togglePhoto = function(photoId) {
   var me = document.getElementById("pic_"+photoId)
   if(me.style.display=="block"){
     me.style.display="none";
   }
   else if (me.style.display=="none"){
     me.style.display="block";
   }
}

hideShow = function(lb) {
   var me = document.getElementById(lb)
   if(me.style.display=="block"){
     me.style.display="none";
   }
   else if (me.style.display=="none"){
     me.style.display="block";
   }
}

grabData = function(data){
  return "https://farm"+data.photo.farm+".staticflickr.com/"+data.photo.server+"/"+data.photo.id+"_"+
            data.photo.secret+".jpg"
}

fromFlickr = function(photoId) {

$.getJSON("https://api.flickr.com/services/rest/?method=flickr.photos.getInfo&api_key=23a138c73bdbe1e68601aa7866924e62&user_id=109924623@N07&photo_id="+photoId+"&lang=en-us&format=json&jsoncallback=?",
  function(data) {
    imgURL = grabData(data)
    var l = document.getElementById("lnk_"+photoId)
    l.href = "https://www.flickr.com/photos/109924623@N07/"+photoId
    var i = document.getElementById("pic_"+photoId)
    i.src=imgURL
    i.onload = function() {
      document.getElementById("status_"+photoId).innerHTML="[Image loaded. Click to show/hide.]"
    }
  })
}
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js","color.js"],
    jax: ["input/TeX","output/HTML-CSS"],
    tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]},
    TeX: {
      Macros: {
        h: ["{\\hat #1}",1],
        b: ["{\\overline #1}", 1],
        row: "{\\mathcal R}",
        col: "{\\mathcal C}",
        nul: "{\\mathcal N}"
      }
    }
  });
</script><script type="text/javascript" src="https://www.isical.ac.in/~arnabc/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="../MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="../tools/htmlwidgets.js"></script>
<link href="../tools/rgl.css" rel="stylesheet"></link>
<script src="../tools/rglClass.src.js"></script>
<script src="../tools/CanvasMatrix.src.js"></script>
<script src="../tools/rglWebGL.js"></script>
</head>
<body>
<a href="http://www.isical.ac.in/~arnabc/">[Home]</a>
<h3>Table of contents</h3>
<ul>
<li>
<a href="#Tree handling functions">Tree handling functions</a>
</li>
<li>&nbsp;&nbsp;&nbsp;
<a href="#Structure of trees">Structure of trees</a>
</li>
<li>&nbsp;&nbsp;&nbsp;
<a href="#Accessing items">Accessing items</a>
</li>
<li>&nbsp;&nbsp;&nbsp;
<a href="#Modifying a tree">Modifying a tree</a>
</li>
<li>&nbsp;&nbsp;&nbsp;
<a href="#Combining trees">Combining trees</a>
</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#Appending">Appending</a>
</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#Laminate">Laminate</a>
</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<a href="#Stitch">Stitch</a>
</li>
</ul>
<hr/>
<h1><a
name="Tree handling functions">Tree handling functions</a></h1>
The most important and frequently used functions in J are the
ones that manipulate the tree structure. As these are unique to
J, these are also the ones that will take more time to
digest. 

<h2><a
name="Structure of trees">Structure of trees</a></h2>

A tree in J is always balanced. This allows an easy way to store
it. Just store the leaf nodes, and also the shape. So if you want
to reshape the tree, just change the shape. This is done
using <font color="red"><code>$</code></font> dyad. If the list has length different from the
product of the shape values, then the list is replicated
(possibly partially). The same symbol <font color="red"><code>$</code></font> used as a monad
will extract the shape of a tree. The monad <font color="red"><code>#</code></font> returns the
number of items in a tree. If we want to see the
underlying list, then you can use the monad <font color="red"><code>,</code></font>
(mysteriously called ravel).

<h2><a
name="Accessing items">Accessing items</a></h2>

To access items we use the <font color="red"><code>{</code></font> family.
 get the first
item use the monad <font color="red"><code>{.</code></font>. To get the last item use the
monad <font color="red"><code>{:</code></font>.  To get an item at a specific
position (0-based) use the dyad <font color="red"><code>{</code></font>.
<p></p>
Most often a tree is best considered as a list of items. Such
 lists are sometimes mere packets of a small number of
 items. There is a quick way to unpack such a tree:
<span class="j">
<pre>
'a b c' =: x
</pre>
</span>
This command expects <font color="red"><code>x</code></font> to be a packet of 3 items. These
 get stored in the variables <font color="red"><code>a</code></font>, <font color="red"><code>b</code></font> and <font color="red"><code>c</code></font>.
<p></p>

 To get a new tree consisting of all the items
except the first use <font color="red"><code>}.</code></font>. If you want to remove the last
item then use the monad <font color="red"><code>}:</code></font>.

<h2><a
name="Modifying a tree">Modifying a tree</a></h2>
The dyad <font color="red"><code>|:</code></font> will transpose the tree, <i>i.e.</i>, reverse the
shape (and the underlying list accordingly). Used as a dyad it
will allow more diverse way to permute the shape (and the
underlying list accordingly).

<h2><a
name="Combining trees">Combining trees</a></h2>
Next we shall discuss three important ways to combine two trees
to produce a bigger tree.
Keeping an analogy in mind might prove helpful here:
<blockquote> When
we work with fractions we often prefer to express them in their
reduced forms. However, when we perform an operation on two
fractions in reduced forms, the immediate result may not be in
reduced form, <i>e.g.</i>, 
$$
\frac 18+\frac 38 = \frac 48.
$$
So we need to do a bit of post-processing (cancellation in this
example) to achieve the reduced form.
</blockquote>
Similarly, J likes to keep its trees balanced (all branches have
same length, and all siblings have same number of children). When
we combine two such trees, the immediate result may not be
balanced. So J performs some post-processing to balance the
tree. It helps to have an idea of what this involves. Basically,
there is only one guiding principle: always pad shorter things to
match longer counterparts. An example will help. Here is an
unbalanced tree:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/unbal.png"></th>
</tr>
<tr>
<th></th>
</tr>
</table>
</center>
The last branch is shorter than the rest, and the second branch
has one less leaf node. To make it balanced J first grows the
short branch until it is as long as the longest branch:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/bal1.png"></th>
</tr>
<tr>
<th></th>
</tr>
</table>
</center>
Now at each level we shall find the maximum number of children,
and pad smaller numbers to the right. We start doing this bottom
up. After the bottom most layer is done, the tree looks like this:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/bal2.png"></th>
</tr>
<tr>
<th></th>
</tr>
</table>
</center>
Next we attack the layer above:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/bal3.png"></th>
</tr>
<tr>
<th></th>
</tr>
</table>
</center>
This process is always done internally. 
<h3><a
name="Appending">Appending</a></h3>
The <font color="red"><code>,</code></font> dyad appends two trees "side by side". 
<center>
<table width="100%">
<tr>
<th><img width="" src="image/append1.png"></th>
</tr>
<tr>
<th>Step 0: The two trees to be appended</th>
</tr>
</table>
</center>
First the trees are combined by merging their root nodes:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/append2.png"></th>
</tr>
<tr>
<th>Step 1: The result of direct appending</th>
</tr>
</table>
</center>
Then the resulting  tree is balanced:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/append3.png"></th>
</tr>
<tr>
<th>Step 2: The final result</th>
</tr>
</table>
</center>
 The simplest case is
of course, where the tree in step 1 is already
balanced. This is what you'll need most of the time (though
often you'll find yourself in the unbalanced situation by
mistake!). There is one situation however, which is not covered
by this: when one of the two trees is just the root node:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/append4.png"></th>
</tr>
<tr>
<th>Step 0: The blue atom to be appended</th>
</tr>
</table>
</center>
 Then
"merging the root nodes" would not produce a tree at all. In
this case, we create a new item of the same shape as the other,
where the atom is <i>replicated in all its leaf nodes</i>:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/append5.png"></th>
</tr>
<tr>
<th>Step 1: The final result</th>
</tr>
</table>
</center>
Intuitively, appending is a way to grow a longer list.

<h3><a
name="Laminate">Laminate</a></h3>
Another natural way to combine two trees is by creating a new
tree with these two trees as items (and then balancing if
needed). This is called lamination, and effected
by <font color="red"><code>,:</code></font>. Here's one example:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/laminate1.png"></th>
</tr>
<tr>
<th>Step 0: the two trees to be
laminated</th>
</tr>
</table>
</center>
The two trees are hung from a common root node.
<center>
<table width="100%">
<tr>
<th><img width="" src="image/laminate2.png"></th>
</tr>
<tr>
<th>Step 1: after combining</th>
</tr>
</table>
</center>
Then we balance the tree:
<center>
<table width="100%">
<tr>
<th><img width="" src="image/laminate3.png"></th>
</tr>
<tr>
<th>Step 2: the final result</th>
</tr>
</table>
</center>
As usual, the most frequently encountered situation is where the
tree in step 1 is already balanced. Intuitively, lamination is
the way to grow a list of lists. 

<h3><a
name="Stitch">Stitch</a></h3>
This is yet another way to combine two trees which is not very
intuitive. If we have a list of $x$-values and a
corresponding list of $y$-values, then stitching will
produce a list of $(x,y)$ pairs. More precisely, given two
trees with equal number of items, the corresponding items pairs
are appended. If the numbers of items are not equal, then J
reports a length error.
<font color="red"><code>|.</code></font>, <font color="red"><code>|:</code></font>,
<font color="red"><code>'a b'=: x</code></font>
<hr/>
<table width="100%" border="0">
<tr>
<td align="left"/>
<td align="right"/>
</tr>
</table>
<hr/>
</body>
</html>
