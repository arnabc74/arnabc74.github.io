
%*******************************************************************************
%*                    START OF AUTOMATICALLY GENERATED TEX FILE                *
%*******************************************************************************
%*                                                                             *
%* This TeX file was automatically generated by the FunnelWeb preprocessor.    *
%* You can typeset this file to produce printed documentation by running it    *
%* through the TeX typesetter using a command such as:                         *
%*    tex thisfilename                                                         *
%* The resultant file thisfilename.dvi can be printed using a command such as: *
%*    lpr -Plaser -d thisfilename.dvi                                          *
%*                                                                             *
%* FunnelWeb is a preprocessor that allows programmers to weave programs and   *
%* their documentation together in a single document. The FunnelWeb program    *
%* analyses such documents producing both program files and typeset            *
%* documentation such as this TeX file.                                        *
%* FunnelWeb was created by Ross N. Williams.                                  *
%*                                                                             *
%* For more information on FunnelWeb see http://www.ross.net/funnelweb/        *
%*                                                                             *
%*******************************************************************************


%===================== Start of FunnelWeb TeX Definitions ======================


% Version
% -------
% This is FunnelWeb TeX Macro Library Version 1.0.


% Copyright
% ---------
% This set of FunnelWeb TeX definitions was written by Ross Williams and was
% originally Copyright (C) 1992 Ross N. Williams.  However, I, Ross Williams,
% hereby forego any claim to Copyright in this set of FunnelWeb TeX definitions
% and hereby authorize that the set of TeX definitions pass into the public
% domain. -- Ross N. Williams, 3:41pm 07-May-1992, Adelaide, Australia.


% Modification
% ------------
% Please record all modifications to these TeX definitions here. Unless
% otherwise specified, all modified definitions fall in the public domain too.
%
% Programmers:
%    RNW  Ross N. Williams  ross@ross.net
%
% Changes:
%    07-May-1992  RNW  Prepared this work for public domain release.
%    10-May-1999  RNW  Added \fwlib macro.


% General Comments
% ----------------
% This set of TeX definitions exists for two reasons:
%
%    1. To shorten and neaten the FunnelWeb TeX output.
%    2. To allow users to fiddle with the output format in their input files
%       (by inserting redefining "\def"s) without having to resort to
%       modifying the FunnelWeb code.
%
% The user is warned that these definitions may be changed from time to time
% (but probably not much). The user should not be too sneaky. In particular,
% users wishing to redefine some of these macros should do so in an explicitly
% defined section at the top of their input file. This will mean that in the
% event of problems, that section can simply be deleted or commented out to
% allow the document to at least be typeset in the default format. Users should
% limit themselves to redefining these macros in such a section and should
% refrain from using the macros throughout their documents.


% Environment Parameters
% ----------------------
% \tolerance tells TeX how tolerant it should be about making bad line and
% page breaks. Here we set it to it's maximum, as
%   1) Computer programs are likely to cause lots of bad breaks.
%   2) In most cases the user would probably rather get the TeX file through
%      TeX without any errors than fiddle with spacings for perfection.
\tolerance=10000

% I don't like indentation as it makes the page look more busy. Instead,
% paragraphs are separated by a little space (see next).
\parindent=0pt

% In many cases, users will produce documents with long runs of paragraphs.
% In order to space out these paragraphs, it is convenient to maintain a
% prevailing non-zero \parskip (end-of-paragaph skip). The only trouble is
% that the skip becomes a problem in macro definitions which require no skip
% and so we have to turn the skip on and off. The following two macros
% simplify this process.
\def\fwparskipon{\parskip=\medskipamount}
\def\fwparskipoff{\parskip=0pt}
\fwparskipon

% Setting raggedbottom allows TeX to leave a bit of space at the bottom of the
% page in order to better vertically align the rest of the page (e.g. skips
% won't stretch as much). It also means that headings are less likely to be
% isolated at the bottom of the page without any following text.
\raggedbottom


% Fonts
% -----
% Most of the typeset output is set in 10pt roman and 10pt tt font.
% The major extra font needs spring from titles and headings.
% For portability's sake we use only the following fonts:
%    cmr10
%    cmbx10
%    cmtt10
% and some enlargements of them. These fonts are all "standard" fonts
% in Plain TeX. See The TeXbook p.350.
\font\fwfontnote=cmr7

\font\fwfontnorm=cmr10
\font\fwfontnorma=cmr10 scaled \magstep1
\font\fwfontnormb=cmr10 scaled \magstep2

\font\fwfontbold=cmbx10
\font\fwfontbolda=cmbx10 scaled \magstep1
\font\fwfontboldb=cmbx10 scaled \magstep2
\font\fwfontboldc=cmbx10 scaled \magstep3
\font\fwfontboldd=cmbx10 scaled \magstep4


% Macros for Stylistic Details
% ----------------------------
% This section contains all the fiddly little macros for setting the details
% of each macro definition.

% Macro definitions are sandwiched by calls to these macros which can be used
% to sort out the spacing before and after the macro definition.
\def\fwbeginmacro{\fwparskipoff\bigskip}
\def\fwendmacro{\fwparskipon\par}

% These macros deal with the macro name and definition line.
\def\fwmacroname#1#2{{\sl #1\/}$\lbrack$#2$\rbrack$}
\def\fwfilename#1#2{{\bf #1}$\lbrack$#2$\rbrack$}
\def\fwzero#1{{\bf Z}}
\def\fwmany#1{{\bf M}}
\def\fwlib#1{{\bf L}}
\def\fwequals{ $\equiv$}
\def\fwplusequals{ $+\equiv$}

% Now for the actual body of the definition. It looks nice to have the tt
% code indented a little. Again, we use macros instead of writing direct TeX,
% so as to allow the user to fiddle this stuff to taste without having to
% modify the FunnelWeb C code.
\def\fwodef{\parindent=15pt\vskip0pt$\lbrace$\parindent=20pt}
\def\fwcdef{$\rbrace$\vskip0pt\parindent=0pt}
\def\fwoquote{`}
\def\fwcquote{'}
\def\fwoparen{$($}
\def\fwcomma{$,$}
\def\fwcparen{$)$}
\def\fwparam#1{$\diamond #1$}
\def\fwparams#1{$(\diamond #1)$}

% These macros deal with the notes that are appended at the end of each
% macro definition. Note that even though \fwisafile,\fwusedin, and \fwseealso
% have the same definition, they are given different names so as to allow the
% user to redefine these macros to typeset each kind of information differently
% if desired.
\def\fwbeginmacronotes{\begingroup\baselineskip=9pt\smallskip}
\def\fwnote#1{{\fwfontnote #1}\par}
\def\fwisafile#1{\fwnote{#1}}
\def\fwusedin#1{\fwnote{#1}}
\def\fwseealso#1{\fwnote{#1}}
\def\fwendmacronotes{\endgroup}


% Macros to Typeset Program Code Verbatim
% ---------------------------------------
% This is by far the hairiest and most difficult part of the typesetting task
% because we have to turn off most of TeX's natural instincts in order to
% typeset the program text exactly as it appears in the input file.
% Two macros are defined to pull this off: \fwbtx and \fwverbatimgobble.
% Their code was inspired by the following sections of "The TeXbook":
%    Appendix D: Dirty Tricks, 3.Verbatim listing, p.380-382.
%    Appendix E: Example Formats, p.421.
% The \fwbtx[ (for "FunnelWeb Begin TeXt") macro does most of the hard work.
% The liberal use of "%" is because I don't understand TeX well enough to
% understand when an end of line will cause trouble, and I am playing it safe.

% Before defining the main \fwbtx macro, we have to stash away some definitions
% in the hidden part of TeX's environment. Let's hope that these "hidden"
% definitions don't affect anything except what is desired to be affected.

% The tt font in which we wish to set the text has two Latin lurking ligatures!
% These are ?` and !`. To disable them, we define the left quote when ACTIVE
% to be defined in such a way as to prevent ligatures. The main TeX text will
% normally not be exposed to this definition because normally the leftquote
% character is not active. The \fwbtx macro temporarily makes the left quote
% character active thus activating the deactivation of left quote ligatures.
% See The TeXbook p.381.
{\catcode`\`=\active \gdef`{\relax\lq}}

% TeX is fairly carefree about spaces and so we have to make it more serious.
% To do so we pull the same trick as above, setting up a definition for active
% space, but only making space active during the span of the verbatim text.
% In Plain TeX the active space is defined to be simply a space, but here we
% define it to be a control space. This ensures that the space cannot
% be gobbled up by one of TeX's mysterious mechanisms when activated.
% See The TeXbook, p.381 and p.352.
{\obeyspaces\global\let =\ }

% Here is the main \fwbtx verbatim text macro.
% Note: The order in which all these pieces of business have to be done is
% still a partial mystery to me. Don't fiddle with this stuff unless you
% think you know what you are doing.
\def\fwbtx[{%
%
% The funnies involved in getting verbatim output are safely housed inside
% this \begingroup, and the \endgroup in \fwverbatimgobble. Groups are used
% instead of curly braces because we have to be able to signal the end of
% this macro with a curly brace.
\begingroup%
%
% \pars at the end of empty lines in the verbatim text won't come out normally
% because TeX is in vertical mode and they get gobbled up. To prevent this,
% we force \par to exit vertical mode first. See The TeXbook p.381.
\def\par{\leavevmode\endgraf}%
%
% Activate the leftquote character so as to avoid ligatures (see above).
\catcode`\`=\active%
%
% The \obeylines macro simply defines end of line (^M) to be \par. This ensures
% that TeX will treat each verbatim line as a new paragraph.
\obeylines%
%
% To get verbatim output, we have to desex all the special characters. This
% is explained in detail in The TeXbook p.380.
\def\do##1{\catcode`##1=12 }\dospecials%
%
% Activate the space character so as to make TeX treat blanks seriously.
% This activation invokes an eralier definition (see above).
\obeyspaces
%
% Interparagraph skips do not help the cause.
% Note: We have to preserve the indentation though, as the code is actually
% indented in the final output. See \fwodef in an earlier section.
\parskip=0pt%
%
% We typeset the verbatim text in tt font (courier on the Macintosh) for a
% number of reasons:
%    - tt font has the same horizontal spacing for each character.
%    - tt font covers the ASCII character set.
%    - tt font doesn't have many surprises (e.g. ligatures).
%    - tt font looks much what you might see on a computer terminal screen.
\tt%
%
% Having set up an environment for verbatim, we are ready to use it.
% By invoking \fwverbatimgobble, this \fwbtx macro gobbles up text verbatim (as
% part of the parameter of \fwverbatimgobble) until it sees the termination
% string "]fwetx=" (the "=" was thrown in to add obscurity as this sequence
% must never occur in the verbatim text).
\fwverbatimgobble}

% The \fwverbatimgobble macro exists to allow \fwbtx to bracket verbatim text.
\def\fwverbatimgobble#1]fwetx={#1\endgroup}


% Table of Contents
% -----------------
% The five levels of table of contents that FunnelWeb supports are identified
% by the five letters [A..E]. These are used throughout the following macros.

% The following macros are utilities to the TOC macros to follow.
\def\fwrule{\medskip\hrule\medskip}
\def\fwqh{\hskip1.5em\relax}
\def\fwbeforesec{\penalty-200\bigskip\medskip\par}

% The following macros are used to typeset the table of contents.
\def\fwtocstart#1{\fwrule\leftline{\fwfontbolda Table of Contents}\fwrule}
\def\fwtoca#1#2{\leftline{{\bf #1 #2}}}
\def\fwtocb#1#2{\leftline{\fwqh #1 #2}}
\def\fwtocc#1#2{\leftline{\fwqh\fwqh #1 #2}}
\def\fwtocd#1#2{\leftline{\fwqh\fwqh\fwqh #1 #2}}
\def\fwtoce#1#2{\leftline{\fwqh\fwqh\fwqh\fwqh #1 #2}}
\def\fwtocfinish#1{\fwrule}

% The following "library" macros define five different strengths of headings
% which can be used later in the section macros.
\def\fwliba#1#2{\vfill\eject{\fwfontboldc #1 #2}\penalty200\smallskip}
\def\fwlibb#1#2{\fwbeforesec{\fwfontboldb #1 #2}\penalty200\smallskip}
\def\fwlibc#1#2{\fwbeforesec{\fwfontnormb #1 #2}\penalty200\smallskip}
\def\fwlibd#1#2{\fwbeforesec{\bf          #1 #2}\penalty200}
\def\fwlibe#1#2{\fwbeforesec{\bf          #1 #2}}

% Here are the macros that actually typeset the section headings throughout
% the document. The fwlib system has been employed so as to easily allow the
% user to redefine the strengths of headings to taste. For example, the
% user could insert in the input document a similar set of definitions to these
% but with the b..e headings set to \fwlibc. This would tone down the output.
\def\fwseca#1#2{\fwliba{#1}{#2}}
\def\fwsecb#1#2{\fwlibb{#1}{#2}}
\def\fwsecc#1#2{\fwlibc{#1}{#2}}
\def\fwsecd#1#2{\fwlibd{#1}{#2}}
\def\fwsece#1#2{\fwlibe{#1}{#2}}


% Support for Explicit Typesetting
% --------------------------------
% FunnelWeb supports pragmas and other constructs that allow
% typesetter-independent typesetting commands to be given. The
% following macros support these features.

% The in-text literal @{sloth@} and emphasise @[walrus@] features.
\def\fwlit#1{{\tt #1}}
\def\fwemp#1{{\it #1}}

% The "@p new_page" pragma.
\def\fwnewpage{\vfill\eject}

% The "@p vskip Nmm" pragma.
\def\fwvskip#1{\null\vskip #1mm}

% The "@p title <font> <align> <text>" pragma.
\def\fwfontnormal#1{{\fwfontnorm {#1}}}
\def\fwfonttitle#1{{\fwfontboldd {#1}}}
\def\fwfontsmalltitle#1{{\fwfontboldb {#1}}}
\def\fwleftline#1{\leftline{#1}}
\def\fwcenterline#1{\centerline{#1}}
\def\fwrightline#1{\rightline{#1}}


% Support for Old FunnelWeb
% -------------------------
% The following macros were used extensively in the first version of
% FunnelWeb and are retained so that these older input files will still
% typeset cleanly.
\def\p#1{{\tt #1}}  % P for Program text.
\def\flagpage#1#2{
   \null
   \vfill
   \centerline{\fwfontboldd #1}
   \vskip 1cm
   \centerline{\fwfontboldd #2}
   \vfill
   \null
   \vfill
}

%====================== End of FunnelWeb TeX Definitions =======================
\fwcenterline{\fwfonttitle{Translating RB to AB}}
\fwcenterline{\fwfontsmalltitle{(BTex.java)}}

\fwtocstart{}
\fwtoca{1}{DFA driver}
\fwtocb{1.1}{Initializing}
\fwtocb{1.2}{Reading the tokens}
\fwtocb{1.3}{The actions}
\fwtocc{1.3.1}{Actions at state 0}
\fwtocc{1.3.2}{Actions at state 1}
\fwtocc{1.3.3}{Actions at state 2}
\fwtoca{2}{Miscel private methods}
\fwtocb{2.1}{The highlevel output function}
\fwtoca{3}{Chores}
\fwtocb{3.1}{Test harness}
\fwtocb{3.2}{File layout}
\fwtocfinish{}

\fwseca{1}{DFA driver}
\fwbeginmacro
\fwmacroname{Private fields}{1}\fwplusequals \fwodef \fwbtx[
private int state;
private boolean hasYaphala;
private int lastPrim;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 1, 3, 6, 10, 19, 26 and 34.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Public methods}{2}\fwplusequals \fwodef \fwbtx[
private Emitter emtr;
public void process() throws IOException {
  int c=-1,tabEntry;
  boolean forceYukta = false;
  String texStr="";
  dbg = 0;

  while(true) {
    if(dbg!=0) {
        System.err.print("State = "+state+"\n");
    }

    ]fwetx=%
\fwmacroname{Get next token}{8}\fwbtx[

    switch(state) {
    case 0 :
        ]fwetx=%
\fwmacroname{Handle state 0}{12}\fwbtx[
        break;
    case 1 :
        ]fwetx=%
\fwmacroname{Handle state 1}{14}\fwbtx[
        break;
    case 2 :
        ]fwetx=%
\fwmacroname{Handle state 2}{21}\fwbtx[
        break;
    case 3 : 
        if(c==Common.EOT) {
          if(dbg!=0) System.err.print( "<END OF TEX>\n");
          state = 0;
        }
        else {
          if(dbg!=0)System.err.println("**"+texStr);
          emtr.emitEng(texStr);
        }
        break;
    case 4 :
     ]fwetx=%
\fwmacroname{Handle state 4}{22}\fwbtx[
     break;
    }
  }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 2.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


\fwsecb{1.1}{Initializing}
\fwbeginmacro
\fwmacroname{Private fields}{3}\fwplusequals \fwodef \fwbtx[
private boolean inError;
private boolean buffered;
private BengLex blex;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 1, 3, 6, 10, 19, 26 and 34.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Constructors}{4}\fwequals \fwodef \fwbtx[
public BTex(Emitter emtr1) {
  emtr = emtr1;
  loadYukta();
}

public void init() {
  state = 0;
  buffered = false;
  inError = false;
}

public void display(String str) throws IOException {
  blex = new BengLex(new StringReader(str));
  process();
}

public BTex(Reader rdr, Emitter emtr1) {
  emtr = emtr1;
  init();
  loadYukta();

  blex = new BengLex(rdr);
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro

\fwbeginmacro
\fwmacroname{Private methods}{5}\fwplusequals \fwodef \fwbtx[
private void loadYukta() {
  int i,count;
  int row=-1,col=-1, yuktaState;

  count = yuktaState = i = 0;
  while(YuktaDat.yuktaList[i] != YuktaDat.EOY) {
     ]fwetx=%
\fwmacroname{Mini automaton}{7}\fwbtx[
  }

  System.err.print("Loaded "+count+" yuktaxars\n");
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 5, 11, 20, 23, 24, 28, 29 and 30.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


Here is how the mini automaton works. It starts at state 0, reads the next
entry (\fwlit{row}, say)in the \fwlit{YuktaDat.yuktaList} array, and moves to 
state 1. If
it meets a -1 in state 1, then it reverts back to state 0. Otherwise, it
reads two consecutive entries of \fwlit{YuktaDat.yukataList}. 
Call them \fwlit{col} and
\fwlit{x}, say. Then the automaton loads the fact that letter \fwlit{row} followed
by letter \fwlit{col} produces yuktaxar \fwlit{x}.
\fwbeginmacro
\fwmacroname{Private fields}{6}\fwplusequals \fwodef \fwbtx[
private int tab[][] = new int[Common.MAXLENIENT+1][50];
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 1, 3, 6, 10, 19, 26 and 34.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Mini automaton}{7}\fwequals \fwodef \fwbtx[
switch(yuktaState) {
  case 0 :
   row = YuktaDat.yuktaList[i++];
   yuktaState = 1;
   break;
  case 1 :
   if(YuktaDat.yuktaList[i] == -1) {
       i++;
       yuktaState = 0;
   }
   else {
       col = YuktaDat.yuktaList[i++];
       if(dbg>1) System.err.print("("+row+","+col+")\n");
       if(row>Common.MAXLENIENT) {
         System.err.println("Error!");
         System.exit(1);
       }
       tab[row][col] = YuktaDat.yuktaList[i++];
       count++;
       if(dbg>1) System.err.print(""+Common.haraph1[row]+" + "+
                                  Common.haraph1[col]+" = "+
                  Common.haraph1[Math.abs(tab[row][col])]+"\n");

   }
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 5.}
\fwendmacronotes
\fwendmacro


\fwsecb{1.2}{Reading the tokens}
Reading the next token from the input RB file is somewhat trickier than it
sounds. We have to take care of error conditions and left overs from past
calls.
\fwbeginmacro
\fwmacroname{Get next token}{8}\fwequals \fwodef \fwbtx[
if(!buffered) {
  ]fwetx=%
\fwmacroname{Read a fresh token}{9}\fwbtx[
}
else {
  if(dbg!=0) System.err.print("Continuing with last token...\n");
  buffered = false;
}

if(c==0) {
  if(dbg!=0) System.err.print("Goodbye\n");
  return;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 2.}
\fwendmacronotes
\fwendmacro


As the automaton reads input tokens, it may happen that when it reaches an
acceptance state, it cannot process the current token in that pass of the
loop. Then that token is left unused  in the variable \fwlit{c}, to be used
during the next pass. We call this  situation \char`\"buffering\char`\" and  indicate
this by making the flag \fwlit{buffered} true.

At EOF \fwlit{LX.yylex} return 0. Then we stop the automaton.


\fwbeginmacro
\fwmacroname{Read a fresh token}{9}\fwequals \fwodef \fwbtx[
if(inError) {
  System.err.print("Skipping upto next punctuation/SOE/EOF...\n\n");
  do {
    Symbol tmp = blex.yylex();
    if(tmp==null) {System.err.println("Done."); return;}
    c = tmp.token;
    yylval = tmp.lexeme;
  } while(c!=Common.PUNCT && c!=0 && c!=Common.SOE);
  inError = false;
}
else {
  Symbol tmp = blex.yylex();
    if(tmp==null) {
      if(state!=0) emit(first,second,0);
      System.err.println("Done."); 
      return;
    }
  c = tmp.token;
  if(c==Common.SPL)
    texStr = tmp.lexStr;
  else
    yylval = tmp.lexeme;
  if(dbg!=0) System.err.println("lexeme = "+yylval);
}
if(dbg!=0) 
  if(state==3)
    System.err.print("Reading new E token... ["+texStr+"]("+c+")\n");
  else
    System.err.print("Reading new B token... ["+yylval+"]\n");
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 8.}
\fwendmacronotes
\fwendmacro

If the automaton has met with an error (flagged by a true \fwlit{inError})
we simply skip upto the next punctuation/SOE/EOF. Note that we cannot
ignore a SOE, since otherwise the lexer will remain in its \fwlit{INITIAL}
start condition inside an embedded English, and all sorts of chaos might
ensue!
\fwsecb{1.3}{The actions}

\fwbeginmacro
\fwmacroname{Private fields}{10}\fwplusequals \fwodef \fwbtx[
private int first, second;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 1, 3, 6, 10, 19, 26 and 34.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


It restores
the automaton to state 0, and turns on the flag \fwlit{inError}. Also, it
prints the line number using the flex global \fwlit{LX.yylineno}. It is for this
reason that the flex input has the \fwlit{\%option yylineno} directive.
\fwbeginmacro
\fwmacroname{Private methods}{11}\fwplusequals \fwodef \fwbtx[
private void error(String s) {
  //System.err.print("ERROR at line "+LX.yylineno+
  //                 " character "+wordCount+": "+s+"\n");
  System.err.print("State = "+state+"\n");
  //System.err.print("Offending input is ["+LX.yytext+"] \n");
  
  //System.err.print("ERROR at line "+
  //                  LX.yylineno+" character "+wordCount+":"+s+"\n"); 
  //System.err.print("Offending input is ["+LX.yytext+"] \n");
  
  inError = true;
  state = 0;
  buffered = false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 5, 11, 20, 23, 24, 28, 29 and 30.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


\fwsecc{1.3.1}{Actions at state 0}

This is the starting state of the automaton. In this state we expect any
token other than \fwlit{+} and \fwlit{\char`\~} and End of English marker. 

Handling the expected token is pretty straightforward. However, if we get
a byanjan we go to state 1 or state 2 according as that byanjan can become
a yuktaxar or not.

In case of a swar we just have to guard against a HAS sign, since a swar
at this state cannot be a kAr.
\fwbeginmacro
\fwmacroname{Handle state 0}{12}\fwequals \fwodef \fwbtx[
switch(c) {
]fwetx=%
\fwmacroname{On PUNCT, NUM, MISC stay at state 0}{13}\fwbtx[

case Common.SWAR :
    if(yylval==Common.HAS) {  /* cannot start with a HAS sign! */
        error("Badly applied HAS sign\n");
    }
    //LX.start=0;
    if(dbg!=0) System.err.print("Swar...\n");
    first = yylval;
    state = 4;
    break;

case Common.BYAN :
    //LX.start=0;
    first = yylval;
    if(dbg!=0) System.err.print("Byanjan\n");
    state = 1;
    break;

case Common.SOT :
    if(dbg!=0) System.err.print("<Start Of TEX>\n");
    state = 3;
    break;

default :
    error("Unexpected token ["+c+"] at state 0");
    break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 2.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{On PUNCT, NUM, MISC stay at state 0}{13}\fwequals \fwodef \fwbtx[
case Common.PUNCT :
    if(dbg!=0) System.err.print("Punctuation...dumped\n");
    emit(yylval,0,0);
    break;
case Common.NUM :
    //LX.start=1;
    if(dbg!=0) System.err.print("Number...dumped\n");
    emit(yylval,0,0);
    break;

case Common.MISC :
    if(dbg!=0) System.err.print("miscel...dumped\n");
    emit(yylval,0,0);
    break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 12.}
\fwendmacronotes
\fwendmacro


\fwsecc{1.3.2}{Actions at state 1}

State 1 is reached when we have already read exactly one byanjan. At state
1 we may expect either a swar (the kAr of the byanjan), or new byanjan
(which may or may not form a yuktaxar with
the first byanjan), or a connectivity directive (ie, + or \char`\~), or a
chandrabindu. If we get anything else (eg, punctuation) then we simply
output the byanjan that we already have, and buffer this token for the
next pass.
\fwbeginmacro
\fwmacroname{Handle state 1}{14}\fwequals \fwodef \fwbtx[
switch(c) {
case Common.SWAR :
    if(dbg!=0) System.err.print("Swar...dumped\n");
    buffered = true;
    state = 2;
    //emit(first,second,yylval-A);
    break;

case Common.PLUS :
    if(dbg!=0) System.err.print("Plus\n");
    forceYukta = true;
    state = 1;
    break;

case Common.CHANDRA :
    if(dbg!=0) System.err.print("chandrabindu\n");
    second = collSec(Common.CHANDRA);
    state = 1;
    break;

case Common.BYAN :
    if(dbg!=0) System.err.print("byanjan\n");
    ]fwetx=%
\fwmacroname{Process consecutive byanjans}{15}\fwbtx[
    break;

case Common.TILDE :
    if(dbg!=0) System.err.print("Tilde...dumped\n");
    emit(first,0,0);
    break;

default :
    buffered = true;
    emit(first,second,0);
    break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 2.}
\fwendmacronotes
\fwendmacro


The trickiest part in the above switch is, of course, handling the
consecutive byanjans. First we deal with the yaphala (YY) case.
If we do not have YY, then we consult the yuktaxar table.

\fwbeginmacro
\fwmacroname{Process consecutive byanjans}{15}\fwequals \fwodef \fwbtx[
if(yylval==Common.YY) {
    hasYaphala = true;
    state = 2;  //no more combining after yaphala
}
else {
    tabEntry = lookUp(first,yylval); /* consult yuktaxar table*/
    if(dbg!=0) {
      System.err.print("\ttab["+NameDat.primName[first]+
                     "("+first+")]["+NameDat.primName[yylval]+
                     "("+yylval+")] = "+tabEntry+"\n");
    }
    if(tabEntry==0) {
        ]fwetx=%
\fwmacroname{When the byanjans cannot combine}{16}\fwbtx[
    }
    else if(tabEntry>2) {
       if(dbg!=0) System.err.print(""+NameDat.primName[first]+" + "+
                                      NameDat.primName[yylval]+" = "+
                                      NameDat.primName[tabEntry]+"\n");

       ]fwetx=%
\fwmacroname{When the byanjans can and should combine}{17}\fwbtx[
    }
    else if(tabEntry<0) {
       ]fwetx=%
\fwmacroname{When the byanjans can, but should not combine}{18}\fwbtx[
    }
    else if(tabEntry==Common.RAPHALA) { /* raphala*/
       if(dbg!=0) System.err.print("Doing raphala\n");
       second = collSec(Common.RAPHALA);
       forceYukta = false;
       state = 1; 
    }
    else if(tabEntry==Common.REF) { /* ref */
       if(dbg!=0) System.err.print("Doing ref\n");
       second = collSec(Common.REF);
       first = yylval;
       forceYukta = false;
    }
    else {
       error("What is this?");
    }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 14.}
\fwendmacronotes
\fwendmacro


The first case is pretty straightforward.
\fwbeginmacro
\fwmacroname{When the byanjans cannot combine}{16}\fwequals \fwodef \fwbtx[
if(dbg!=0) System.err.print("Keeping separate\n");
if(!forceYukta) {
    emit(first,second,0);
}
else {
    emit(first,second,Common.HAS);
}

buffered = true;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 15.}
\fwendmacronotes
\fwendmacro


The next case is simpler still. If the byanjans \fwemp{should} combine, then
just go ahead and combine them! Notice that in case the user used a \fwlit{\char`\~}
to separate them, the automaton would not have come to this point!
If th resulting yuktaxar cannot take any more byanjan, then go  to state
2.
\fwbeginmacro
\fwmacroname{When the byanjans can and should combine}{17}\fwequals \fwodef \fwbtx[
first = tabEntry;
forceYukta = false;
if(dbg!=0) System.err.print("Combining\n");
state = 1;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 15.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{When the byanjans can, but should not combine}{18}\fwequals \fwodef \fwbtx[
if(dbg!=0) System.err.print("Can combine, but should not\n");
if(forceYukta) {
    int temp;
    temp = -tabEntry;
    if(temp==Common.RAPHALA) {
       second = Common.RAPHALA;
       state = 2; //nomore yukta after raphala
    }
    else if(temp==Common.REF) {
       first = yylval;
       second = Common.REF;
    }
    else {
       first = temp;
       state = 1;
    }
}
else {
    emit(first,second,0);
    buffered = true;
}

forceYukta = false;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 15.}
\fwendmacronotes
\fwendmacro


The secondaries may occur over more than one tokens. The program has to
collate and combine them in a single secondary. The entire procedure is
governed by the \fwlit{combSec} matrix.
\fwbeginmacro
\fwmacroname{Private fields}{19}\fwplusequals \fwodef \fwbtx[
private int combSec[][]= {
  {Common.NOTHING, Common.RAPHALA, Common.REF, Common.CHANDRA},
  {Common.NOTHING, Common.NOTHING, Common.REF_RAPHALA, Common.RAPHALA_CHANDRA},
  {Common.NOTHING, Common.REF_RAPHALA, Common. NOTHING, Common.REF_CHANDRA},
  {Common.NOTHING, Common.RAPHALA_CHANDRA, Common.REF_CHANDRA,  Common.NOTHING}
};
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 1, 3, 6, 10, 19, 26 and 34.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro

If \fwlit{i}-th secondary is followed by the \fwlit{j}-th
secondary then the software combines them into the \fwlit{combSec[i][j]}-th
secondary. Notice that the diagonals are all zero. So repeated secondaries
cancel out.


\fwbeginmacro
\fwmacroname{Private methods}{20}\fwplusequals \fwodef \fwbtx[
private int collSec(int newSec) {
  if(combSec[second][newSec]!=0) {
    return combSec[second][newSec];
  }
  else {
    error("Insensible secondaries");
  }
  return 0;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 5, 11, 20, 23, 24, 28, 29 and 30.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro



\fwsecc{1.3.3}{Actions at state 2}

State 2 means we already have a byanjan (simple/yukta) that cannot bear
extra load. So
now only a swar or a punctuation can relieve it, ie send it back to state
0. However, it might still care for a yaphala or raphala, which will take
it on to state 3.

\fwbeginmacro
\fwmacroname{Handle state 2}{21}\fwequals \fwodef \fwbtx[
switch(c) {
case Common.SWAR:
   if(dbg!=0) System.err.print("swar...dumped\n");
   if(hasYaphala) 
      emit(first,second,Common.YAPH+yylval-Common.A);
   else
      emit(first,second,yylval-Common.A);    
   break;

default:
   error("Expecting swar or chandrabindu.");
   break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 2.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Handle state 4}{22}\fwequals \fwodef \fwbtx[
switch(c) {
case Common.CHANDRA :
    if(dbg!=0) System.err.print("chandrabindu\n");
    second = collSec(Common.CHANDRA);
    if(dbg!=0) System.err.print("******first = "+first+
                                " second = "+second+"\n");
    emit(first, second, 0);
    break;
default:
    if(dbg!=0) System.err.print("dumping the swar\n");
    buffered = true;
    emit(first, second, 0);
    break;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 2.}
\fwendmacronotes
\fwendmacro



\fwseca{2}{Miscel private methods}
\fwsecb{2.1}{The highlevel output function}

This function is supposed to write one AB character corresponding to the
triple (\fwlit{p},\fwlit{s},\fwlit{v}). 

\fwemp{Caution:}

1. It has the side effect that it sets restores the automaton to
state 0, and reinitializes \fwlit{first} and \fwlit{second} to 0.

2.Never use this function to emit embedded English!

If \fwlit{p} is a number/punctuation then it simply dumps \fwlit{p}. Else, it
checks if there is any secondary part. If not, then it dumps a single 0
bit. Otherwise, it dumps \fwlit{s} after a single 1 bit. Finally it dumps \fwlit{v}.


\fwbeginmacro
\fwmacroname{Private methods}{23}\fwplusequals \fwodef \fwbtx[
private int lookUp(int r, int c) {
  if(r>Common.MAXLENIENT) {
    if(c==Common.R) return Common.RAPHALA;
    return 0;
  }
  return tab[r][c];
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 5, 11, 20, 23, 24, 28, 29 and 30.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Private methods}{24}\fwplusequals \fwodef \fwbtx[
private void emit(int p , int s, int v) {
  state = first = second = 0;
  hasYaphala = false;
  emtr.emit(p,s,v);
}  
private void emit1(int p , int s, int v) {
  boolean yaphalaPresent;


  if(dbg!=0) System.err.print("***p = "+p+" s = "+s+" v = "+v+"\n");
  left = mod1 = mid = mod2 = right1 = right2 = "";
  yaphalaPresent = false;
  ]fwetx=%
\fwmacroname{Check presence of yaphala}{25}\fwbtx[

  switch(v) {
    ]fwetx=%
\fwmacroname{Cases for different vowel signs}{27}\fwbtx[
    default :
      error("Unknown vowel sign: "+v+"\n");
  }

  primSec(p,s);
  printIt();
  state = first = second = 0;
  hasYaphala = false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 5, 11, 20, 23, 24, 28, 29 and 30.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Check presence of yaphala}{25}\fwequals \fwodef \fwbtx[
if(v>=Common.YAPH) {
    v -= Common.YAPH;
    yaphalaPresent = true;
}
else {
    yaphalaPresent = false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 24.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Private fields}{26}\fwplusequals \fwodef \fwbtx[
private String left,mod1,mid,mod2,right1,right2;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 1, 3, 6, 10, 19, 26 and 34.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Cases for different vowel signs}{27}\fwequals \fwodef \fwbtx[
case Common.AA_KAR : 
   if(yaphalaPresent) {
     right1="Y";
     right2="a";
   }
   else {
     right1="a";
   }
   break;
case Common.II_KAR : 
   right1="ii";
   if(yaphalaPresent) right2="Y";
   break;
case Common.HAS_KAR :
   right1=":/";
   if(yaphalaPresent) right2="Y";
   break;
case Common.O_KAR :
   left = "e";
   right1 = "a";
   if(yaphalaPresent) right2="Y";
   break;
case Common.OU_KAR :
   left="e";
   if(yaphalaPresent) {
     right1="Y";
     right2="ou";
   }
   else {
       right1="ou";
   }
   break;
case Common.OI_KAR :
   left="{oi}";
   if(yaphalaPresent) right1="Y";
   break;
case Common.E_KAR :
   left="e";
   if(yaphalaPresent) right1="Y";
   break;
case Common.I_KAR :
   left="i";
   if(yaphalaPresent) right1="Y";
   break;
case Common.U1_KAR :
   right1="u";
   if(yaphalaPresent) right2="Y";
   break;
case Common.UU_KAR :
   right1="uu";
   if(yaphalaPresent) right2="Y";
   break;
case Common.RRI_KAR:
   right1="rR";
   if(yaphalaPresent) right2="Y";
   break;
case Common.A_KAR:
   if(yaphalaPresent) right1="Y";
   break;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 24.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Private methods}{28}\fwplusequals \fwodef \fwbtx[
private void primSec(int p, int s) {
  switch(s) {
   case Common.RAPHALA:
     if(!raphAbsorbed(p)) {
       mid=NameDat.primName[p];
       mod2="R";
     }
     break;
   case Common.REF:
     mod1="r/";
     mid=NameDat.primName[p];
     break;
   case Common.CHANDRA:
     mid=NameDat.primName[p];
     mod2="NN";
     break;
   case Common.REF_RAPHALA:
     mod1="r/";
     if(!raphAbsorbed(p)) {
       mid=NameDat.primName[p];
       mod2="R";
     }
     break;
   case Common.REF_CHANDRA:
     mod1="r/";
     mod2="NN";
     break;
   case Common.NOTHING:
     mid=NameDat.primName[p];
     break;
   }
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 5, 11, 20, 23, 24, 28, 29 and 30.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Private methods}{29}\fwplusequals \fwodef \fwbtx[
boolean raphAbsorbed(int p) {
  switch(p) {
    case Common.K :
     mid="kR";
     return true;
    case Common.T :
     mid="tR";
     return true;
    case Common.BH :
     mid="bhR";
     return true;
    case Common.N_T :
     mid="n/tR";
     return true;
    case Common.S_T :
     mid="s/tR";
     return true;
    case Common.S_K :
     mid="s/kR";
     return true;
   }
  return false;
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 5, 11, 20, 23, 24, 28, 29 and 30.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro


\fwbeginmacro
\fwmacroname{Private methods}{30}\fwplusequals \fwodef \fwbtx[
private void printIt() {
  System.out.print(left);
  System.out.print(mod1);
  System.out.print(mid);
  System.out.print(mod2);
  System.out.print(right1);
  System.out.print(right2);
  System.out.flush();
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 5, 11, 20, 23, 24, 28, 29 and 30.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro




\fwseca{3}{Chores}
\fwsecb{3.1}{Test harness}
\fwbeginmacro
\fwmacroname{Test harness}{31}\fwequals \fwodef \fwbtx[
public void main(String args[]) throws Exception {
   int i,j,k;
/*
   ]fwetx=%
\fwmacroname{Open files}{32}\fwbtx[
  */ 

   dbg = 0;

   //process(new FileReader(args[0]));
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro



\fwbeginmacro
\fwmacroname{Open files}{32}\fwequals \fwodef \fwbtx[
if(argc==2){
    sprintf(fileName,""+argv[1]+".rb");
    //LX.yyin = fopen(fileName,"r");
    sprintf(fileName,""+argv[1]+".tex");
    fOut = fopen(fileName,"w");
    sprintf(fileName,""+argv[1]+".lis");
    fErr = fopen(fileName,"w");
   }
else {
    System.err.print("Usage: rb2ab <fileRoot>\n");
    exit(1);
   }
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwusedin{This macro is invoked in definition 31.}
\fwendmacronotes
\fwendmacro


\fwsecb{3.2}{File layout}
\fwbeginmacro
\fwfilename{BTex.java}{33}\fwequals \fwodef \fwbtx[
import java.io.*;

public class BTex {
 
int yylval;

]fwetx=%
\fwmacroname{Private fields}{1}\fwbtx[
]fwetx=%
\fwmacroname{Constructors}{4}\fwbtx[
]fwetx=%
\fwmacroname{Public methods}{2}\fwbtx[
]fwetx=%
\fwmacroname{Private methods}{5}\fwbtx[
]fwetx=%
\fwmacroname{Test harness}{31}\fwbtx[
}
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwisafile{This macro is attached to an output file.}
\fwendmacronotes
\fwendmacro


It is important that flex (\fwemp{and NOT lex}) be
used to produce this file. It is obtained by running flex on the  file
\fwlit{beng.lex}.  

The file \fwlit{yukta.h} has the  yuktaxar codes defined in it.



\fwbeginmacro
\fwmacroname{Private fields}{34}\fwplusequals \fwodef \fwbtx[
private int dbg;
]fwetx=%
\fwcdef 
\fwbeginmacronotes
\fwseealso{This macro is defined in definitions 1, 3, 6, 10, 19, 26 and 34.}
\fwusedin{This macro is invoked in definition 33.}
\fwendmacronotes
\fwendmacro



\bye


%*******************************************************************************
%*                    END OF AUTOMATICALLY GENERATED TEX FILE                  *
%*******************************************************************************

