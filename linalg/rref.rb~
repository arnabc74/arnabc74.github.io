<html>
  <head>
<title>Simplex</title>

<SCRIPT>
<![CDATA[
function assert(boolCond) {
  if(!boolCond) alert("ERROR");
}

function printf(str) {
  document.getElementById("rule").innerHTML = str;
}

function printf1(str) {
  document.getElementById("exm").innerHTML = str;
}

function printf2(str) {
  document.getElementById("exm").innerHTML += str;
}

function Frac(n,d) {
  assert(d>0);  
  this.num=n;
  this.den = d;
  this.toString= function() {
    if(this.den==1)
      return this.num;
    else
      return "<sup>"+this.num+"</sup>&frasl;<sub>"+this.den+"</sub>";
  }
} 

var  m, n, pi, pj, firstNegbi;
var tab;
var row,
    col;


function gcd(a,b) {
  var divisor, dividend, remainder;

  if(b==0) alert('ERROR: b==0');

  divisor = (b>0? b: -b);
  dividend = (a>0? a: -a);
  
  while(1) {

    remainder = dividend % divisor;

    if(remainder==0) return divisor;

    dividend = divisor;
    divisor = remainder;
  }
  return -1;
}

function reduce(a) {
  var d,ans;

  if(!(a.den>0)) alert('ERROR: a.den <= 0');

  d = gcd(a.num,a.den);
  ans = new Frac(a.num/d,a.den/d);
  
  if(ans.den < 0) {
    ans.num = -ans.num;
    ans.den = -ans.den;
  }
  return ans;
}

function add(a, b) {
  var den,num;

  assert(a.den>0);  
  assert(b.den>0);

  den = a.den * b.den;
  num = a.num*b.den + a.den*b.num;

  return reduce(new Frac(num,den));
}

function sub(a, b) {
  var den, num;

  assert(a.den>0);  
  assert(b.den>0);

  den = a.den * b.den;
  num = a.num*b.den - a.den*b.num;
  return reduce(new Frac(num,den));
}

function mul(a, b) {
  var num, den;

  assert(a.den>0);  
  assert(b.den>0);

  den = a.den * b.den;
  num = a.num * b.num;
  
  return reduce(new Frac(num,den));
}

function dvd(a, b) {
  var den, num;

  assert(a.den>0);  
  assert(b.den>0);
  assert(b.num!=0);

  den = a.den * b.num;
  num = a.num * b.den;
  if(den < 0) {
    den = -den;
    num = -num;
  }

  return reduce(new Frac(num,den));
}

function print(a) {
  if(a.den==1)
    return ""+a.num;
  else
    return "<sup>"+a.num+"</sup>&frasl;<sub>"+a.den+"</sub>";
}


function isNeg(a) {
  assert(a.den>0);
  return (a.num < 0);
}

function isNonpos(a) {
  assert(a.den>0);
  return (a.num <= 0);
}

function isPos(a) {
  assert(a.den>0);
  return (a.num > 0);
}

function isNonneg(a) {
  assert(a.den>0);
  return (a.num >= 0);
}

function neg(a) {
  var num, den;
  assert(a.den>0);
  num = -a.num;
  den = a.den;

  return reduce(new Frac(num,den));
}

function oneBy(a) {
  var num, den;

  assert(a.num!=0);
  assert(a.den>0);
  num = a.den;
  den = a.num;
  if(den < 0) {
    den = -den;
    num = -num;
  }
  assert(den>0);
  return reduce(new Frac(num,den));
}


function pivot() {
  var i,j;
  var temp;

  //alert("\n>>Pivoting with pivot @ (%d, %d)\n",pi+1,pj+1);

  for(i=0;i<=m;i++) {
    if(i==pi) continue;
    for(j=0;j<=n;j++) {
      if(j==pj) continue;
      tab[i][j] = sub(tab[i][j],
                      dvd(mul(tab[i][pj],tab[pi][j]),
                          tab[pi][pj]
                          )
                      );
    }
  }


  for(i=0;i<=m;i++) {
    if(i==pi) continue;
    tab[i][pj] = neg(dvd(tab[i][pj],tab[pi][pj]));
  }

  for(j=0;j<=n;j++) {
    if(j==pj) continue;
    tab[pi][j] = dvd(tab[pi][j],tab[pi][pj]);
  }

  tab[pi][pj] = oneBy(tab[pi][pj]);

  temp = row[pi];
  row[pi] = col[pj];
  col[pj] = temp;

  dump(pi,pj,"red");
}

//------Reduce2.m-----

rref(m):=(
          nrow:length(m),
          ncol:length(transpose(m)),

          m1: copymatrix(m),

          mat2lat(m),
          texput(blank,""),
          trans:blank,
          lead:1,
for(p=0;p<m;p++) {

  /*Search for lead*/                           
  for(c=lead;c<n;c++) {
      for(r=p;r<nrow;r++) {
        if(m[r][c] != 0) {
          found  = true
          break
        }
      }
    if(found) break
  }
   

  if(!found) {
    print("Done.")
  }

  lead= c

  if(r!=p) {
    tmp = m[p]
    m[p] = m[r]
    m[r] = tmp
    tex(S(p,r)),
    mat2lat(m)
  }

  pivot= m[p][lead]

  if(pivot!=1) {
    m[p]= m[p]/pivot
  }

  for i from 1 thru nrow  do 
    if(i#p) then (

      trans:A(p,i,-m[i][lead]).trans,

      m[i]: m[i] - m[p]*m[i][lead]
    ),

    /*tex(trans),*/
    print(m),
    mat2lat(m)
    
                           ));

/*print("So the inverse is");
minv:invert(m1);
tex(minv);*/



//------Reduce2.m ends-----
//Phase II methods

function step30a() {
  printf("<b>(30)</b>Find the pivotal column as any column \
    with negative entry in the bottom margin. \
    <p>No such column? Then we have found optimal solution."); 
  state = "30b";
}

function step30b() {
  foundOpti = 1;

  for(j=0;j<n;j++) {
    if(isNeg(tab[m][j])) {
      pj = j;
      foundOpti = 0;
      break;
    }
  }

  if(foundOpti) {
    printf1("No negative number in the bottom margin. \
So found optimal.");
    state = "opti";
  }
  else {
    printf1("The "+(pj+1)+"-th number of the bottom margin \
is negative. So the pivotal column is "+(pj+1));  
    dump(-1,pj,"red");
    state = "31a";
  }
}

function step31a() {
  printf("<b>(31)</b> Next we shall find the pivotal row. \
Work down the pivotal column. \
For each positive number, divide the right margin number \
in the row by it. The row producing the minimum answer \
is taken as the pivotal row. \
<p>No positive number in this column? Then the LPP \
is unbounded.");
  state = "31b";
}

function step31b() {
  printf1((pj+1)+" is the pivotal column. Let's work down \
this column.<UL>");
  bdd = 0;
  argmin = -1;
  for(i=0;i<m;i++) {
    if(isNonpos(tab[i][pj])) {
      printf2("<LI> Row "+(i+1)+": "+tab[i][pj]+" &le; 0, so ignored.</LI>\n");
      continue;
    }
    bdd = 1;
    ratio = dvd(tab[i][n],tab[i][pj]);
    printf2("<LI> Row "+(i+1)+": "+tab[i][n]+"&divide;"+tab[i][pj]+
" = "+ratio);

    if((argmin < 0) || (isNeg(sub(ratio, minRatio)))) {
      minRatio = ratio;
      argmin = i;
    }
    printf2("</LI>\n");
  }
  printf2("</UL>\n");
  if(!bdd) {
    printf1("No positive number found, so the LPP is unbounded.");
  state = "unbdd";
  }
  else {
    printf2("The minimum among these is "+minRatio);
    printf2("It is in "+(argmin+1)+"-th row, which we therefore \
select as our  pivotal row.");

    pi = argmin;
    dump(pi,pj,"red");
    state = "32a";
  }
}

function step32a() {
  printf("<b>(32)</b>Pivot");
  state = "32b";
}

function step32b() {
  pivot();
  printf1("Pivot");
  state = "30a";
}


//Phase I methods

function step1a() {
    printf("<b>(1)</b>ডানদিকের মার্জিনে প্রথম কোথায় negative সংখ্যা \
    রয়েছে দ্যাখো, সেই row-টা নাও. \
<p>ডানদিকের মার্জিনে কোনো negative সংখ্যা নেই? \
তার মানে আমরা একটা feasible solution পেয়ে গেছি. এবার তবে  phase II শুরু হবে.");

  state = "1b";
 }

function step1b() {
    foundFeas = true;
    for(i=0;i<m;i++) {
      if(isNeg(tab[i][n])) {
	foundFeas = false;
	firstNegbi = i;
	break;
      }
    }
    
    if(!foundFeas) {
      printf1("ডানদিকের মার্জিনে প্রথম negative সংখ্যা রয়েছে "+(firstNegbi+1)+" নং row-তে.");
     dump(firstNegbi,-1,"blue");
     state = "2a";
    }
    else {
      printf1("ডানদিকের মার্জিনে কোনো negative সংখ্যা নেই. তার মানে একটা  feasible solution পেয়ে গেছি.");
      state = "30a";
    }
}

function step2a() {
  printf("<b>(2)</b>এবার একটা pivotal column বার করব. \
এর জন্য আগের ধাপে যে row-টা বার করেছিলে তার মূল অংশে কোনো  negative সংখ্যা বার করো.\
সেটা যে column-এ আছে, সেটাই  pivotal column নাও. \
<p>যদি এরকম্ কোনো negative সংখ্যা না থাকে, \
তবে কোনো feasible soln নেই.");

  state = "2b";
}

var imposs;
var negElt;

function step2b() {
  printf1("আমরা আগের ধাপে "+(firstNegbi+1)+"নং row-টা নিযেছিলাম.<br/>");
 
  imposs = true;
  for(j=0;j<n;j++) {
    if(isNeg(tab[firstNegbi][j])) {
      negElt = tab[firstNegbi][j];
      imposs = false;
      pj = j;
      break;
    }
  }

  if(imposs) 
     printf2("নীল row-এর মূল অংশে কোনো negative সংখ্যা নেই. \
অতএব গল্প শেষ, কোনো feasible solution নেই.");
  else {
     printf2(negElt+" হল এই row-এর্ মূল অংশে একটা negative সংখ্যা. \
এটা রয়েছে  "+(pj+1)+"-নং  column-এ.");
     printf2("তাই  pivotal column নেব  "+(pj+1)+".");
     dump(-1,pj,"red");
  }

  state = "3a";
}


function step3a() {
  printf("<b>(3)</b>এবার একটা  pivotal row খুঁজব. \
এর জন্য pivotal column ধরে নামতে থাকো. \
যেই একটা negative number পাবে, অমনি দ্যাখো সেই row-তে ডান মার্জিনের সংখ্যাটা &le;0 কিনা. \
যদি হয়, তবে মার্জিনের সংখ্যাটাকে pivotal column-এর্ সংখ্যাটা দিয়ে ভাগ করে দাও. \
এইভাবে সবচয়ে ছোটো সংখ্যাটা যে row-তে পাবে, সেটাকেই নেব pivotal row.");
  state = "3b";
}

function step3b() {
  printf1((pj+1)+" ছিল আমাদের  pivotal column. এটা ধরে নামা যাক.");

  minRatio = dvd(tab[firstNegbi][n],tab[firstNegbi][pj]);
  argmin = firstNegbi;

  printf2("<UL>\n");
  for(i=0;i<m;i++) {
    if(isNonneg(tab[i][pj])) {
      printf2("<LI>"+tab[i][pj]+"হিসেবে নেব না, কারণ &ge;0.</LI>\n");
      continue;
    }
    if(isPos(tab[i][n])) {
      printf2("<LI>হিসেবে নেব না, কারণ মার্জিনের "+tab[i][n]+" > 0.</LI>");
      continue;
    }

    ratio = dvd(tab[i][n],tab[i][pj]);
    printf2("<LI>"+tab[i][n]+" &divide; "+tab[i][pj]+" = "+ratio);
    printf2("</LI>\n");
    if(isNeg(sub(ratio,minRatio))) {
      minRatio = ratio;
      argmin = i;
    }
  }
  printf2("</UL>\n");
  printf2("এদের মধ্যে সবচেয়ে  ছোটোটা হল  "+minRatio);

  printf2("এটা রয়েছে  "+(argmin+1)+" নং  row-তে. সেটাই আমাদের pivotal row নেব.");

  pi = argmin;
  dump(pi,pj,"red");
  state = "4a";
}

function step4a() {
  printf("<b>(4)</b>এবার  pivot করব.");
  state = "4b";
}

function step4b() {
  pivot();
  printf1("Tableau-তে দ্যাখো.");
  state = "1a";
}

var foundFeas = false;
var state = "1a";

//GUI methods

function createTable() {
  m = document.getElementById("nrow").value;
  n = document.getElementById("ncol").value;

  
  row = new Array(m);
  for(i=0;i<m;i++)
    row[i] = "Y"+(i+1);

  col = new Array(n);
  for(j=0;j<n;j++)
    col[j] = "X"+(j+1);


  var str = "<table><tr><th></th>";
  for(j=0;j<n;j++)
    str += "<th>"+col[j]+"</th>";
  str += "<th width=1 rowspan="+(m+3)+" bgcolor=black></th>"

  str += "</tr>";
  for(i=0;i<=m;i++) {
    if(i<m) 
      str += "<tr><th>"+row[i]+"</th>";
    else 
      str += "<tr><th width=1 colspan="+(n+4)+" bgcolor=black></th></tr><tr><th></th>";
    for(j=0;j<=n;j++) {
      str += "<td><input type='text' id='"+i+"_"+j+"' /></td>";
    }
    str += "</tr>";
  }
  str += "</table>"
  document.getElementById("tbl").innerHTML = str;
  state = "1a";
}

function asFrac(str) {
  var tokens = str.split("/");
  if(tokens.length==1) {
    return new Frac(str,1);
  }
  else {
    return new Frac(tokens[0],tokens[1]);
  }
}

function loadTable() {
  tab = new Array(m+1);
  for(i=0;i<=m;i++) {
    tab[i] = new Array(n+1);
    for(j=0;j<=n;j++) {
      tmp = document.getElementById(i+"_"+j).value;
      tab[i][j] = asFrac(tmp);
    }
  }  

  document.getElementById("tbl").innerHTML = "";
  dump(-1,-1,"red");
}


function dump(hiRow, hiCol, hiRang) {

  var str = "<table cellspacing=10><tr><th></th>";
  for(j=0;j<n;j++)
    str += "<th>"+col[j]+"</th>";
  str += "<th width=1 rowspan="+(m+3)+" bgcolor=black></th>"

  str += "</tr>";
  for(i=0;i<=m;i++) {
    if(i<m) 
      str += "<tr><th>"+row[i]+"</th>";
    else 
      str += "<tr><th width=1 colspan="+(n+4)+" bgcolor=black></th></tr><tr><th></th>";
    for(j=0;j<=n;j++) {
      str += "<td>"
      if(i == hiRow || j == hiCol) str += "<b><font color="+hiRang+">";

      str += tab[i][j];
      if(i == hiRow || j == hiCol) str += "</font></b>";
      str += "</td>";
    }
    str += "</tr>";
  }
  str += "</table>"

  document.getElementById("tblout").innerHTML = str;
}



function dostep() {
  printf1("");
  eval("step"+state+"()");
}

function randomise() {
  for(i=0;i<=m;i++)
    for(j=0;j<=n;j++) 
      document.getElementById(i+"_"+j).value = 
        Math.floor(20*Math.random())-10;


    document.getElementById(m+"_"+n).value = "0";
}

alert("Simplex algorithm loaded.");

]]></SCRIPT>
<HEAD1>Simplex</h1>

  If the problem is
<PRE>
  max x<sub>1</sub> + 3x<sub>2</sub>
  subj to
  x<sub>1</sub> + 2x<sub>2</sub> &le; 10
  x<sub>1</sub>, x<sub>2</sub> &ge; 0
</PRE>

  then you should enter:
<Q> 
No. of constraints = 1 (not counting nonnegativity constraints),<br>
No. of variables =2.
</Q>

 The table should be: 

<PRE>
 1  2 |  10
------+----
-1 -3 |   0
</PRE>


<h2>Interactive calculator</h2>
<form>
  Number of constraints: <input type='text' id="nrow"/>
  Number of variables: <input type='text' id="ncol"/>
<p>
  <input type="button" value="Create table" onclick="createTable()">
<p>
  <div id="tbl"></div>

  <input type="button" value="Random problem" onclick="randomise()">
  <input type="button" value="Read" onclick="loadTable()">
  <input type="button" value="Step" onclick="dostep()">
</form>
<table width=100% valign=top border=0 cellspacing=20><tr><td width=50% rowspan=2>
<b>Tableau:</b><p><div id="tblout">
</div></td><td width=50%><b>Rule:</b><p><div id="rule">
  </div></td></tr>
<tr><td><b>In our case:</b><p>
<div id="exm">
</div></td></tr></table>
<hr>
<h1>The algorithm</h1>
<h2>Phase I</h2>
Go on doing these steps in this order in a loop.
<dl>
  <dt><b>Step 1:</b> </dt>
  <dd>Find a blue row. (On failure go to phase II: found feasible
  solution.)<br>
<i><font color="red">Details: The blue row is the first row with a negative number in the 
right margin.
</font></i></dd>

  <dt><b>Step 2:</b> </dt>
  <dd>Find a pivotal column. (On failure give up: no feasible
  solution.)<br>
<i><font color="red">Details: Find any negative number in the main part of the row identified in the last step.
 Take its column as the pivotal column.</font></i></dd>

  <dt><b>Step 3:</b> </dt>
  <dd>Find a pivotal row. (Never fails.)<br>
<i><font color="red">Details: For this go down the pivotal column. 
Everytime we meet a negative number, we shall divide the 
the right margin number (if nonpos) in the row by it. 
The row producing the minimum number is the  
pivotal row.</font></i></dd>

  <dt><b>Step 4:</b> </dt>
  <dd>Do pivoting. (Never fails.)</dd>
</dl>

<h2>Phase II</h2>
Go on doing these steps in this order in a loop.
<dl>
  <dt><b>Step 30:</b> </dt>
  <dd>Find a pivotal column. (On failure stop: found optimal
  solution.)<br>
<i><font color="red">Details: Find the pivotal column as any column
    with negative entry in the bottom margin.</font></i>
</dd>

  <dt><b>Step 31:</b> </dt>
  <dd>Find a pivotal row. (On failure give up: unbounded feasible
  region.)<br>
<i><font color="red">Details: Work down the pivotal column.
For each positive number, divide the right margin number
in the row by it. The row producing the minimum answer
is taken as the pivotal row.</font></i></dd>

  <dt><b>Step 32:</b> </dt>
  <dd>Do pivoting. (Never fails.)</dd>
</dl>

<h1>Pivoting</h1>
<table border=0 cellspacing=10>
  <tr><th>Intially</th><th>(1) Swap labels.</th>
    <th>(2) Change general elements.</th>
</tr>
<tr><td>
<table border=1>
  <tr><th><th></th><th>Col</th><th></th></tr>
  <tr><th><td width=100 height=100 bgcolor="#cccccc" align="center"
  valign="center">c</td>
<td bgcolor="#ffcccc" valign="center">a</td>
<td width=50 bgcolor="#cccccc"></td></tr>

  <tr><th>Row<td bgcolor="#ccffcc" align="center">b</td>
  <td>p</td>
  <td bgcolor="#ccffcc"></td></tr>
  <tr><th><td height=50 bgcolor="#cccccc"></td>
  <td bgcolor="#ffcccc"></td>
  <td bgcolor="#cccccc"></td></tr>
</table>
</td>

<td>
<table border=1>
  <tr><th><th></th><th>Row</th><th></th></tr>
  <tr><th><td width=100 height=100 bgcolor="#cccccc" align="center"
  valign="center"></td>
<td bgcolor="#ffcccc" valign="center"></td>
<td width=50 bgcolor="#cccccc"></td></tr>

  <tr><th>Col<td bgcolor="#ccffcc" align="center"></td>
  <td></td>
  <td bgcolor="#ccffcc"></td></tr>
  <tr><th><td height=50 bgcolor="#cccccc"></td>
  <td bgcolor="#ffcccc"></td>
  <td bgcolor="#cccccc"></td></tr>
</table>

</td><td>
    

<table border=1>
  <tr><th><th></th><th>Row</th><th></th></tr>
  <tr><th><td width=100 height=100 bgcolor="#cccccc" align="center"
              valign="center">c-(ab/p)</td>
<td bgcolor="#ffcccc" valign="center"></td>
<td width=50 bgcolor="#cccccc"></td></tr>

  <tr><th>Col<td bgcolor="#ccffcc" align="center"></td>
  <td></td>
  <td bgcolor="#ccffcc"></td></tr>
  <tr><th><td height=50 bgcolor="#cccccc"></td>
  <td bgcolor="#ffcccc"></td>
  <td bgcolor="#cccccc"></td></tr>
</table>

</tr>
<tr>
<th>(3) Change non-pivot elements in  pivotal row.</th>
<th>(4) Change non-pivot elements in  pivotal column.</th>
<th>(5) Change pivot element.</th>
</tr>

<tr><td>
<table border=1>
  <tr><th><th></th><th>Row</th><th></th></tr>
  <tr><th><td width=100 height=100 bgcolor="#cccccc" align="center"
              valign="center">c-(ab/p)</td>
<td bgcolor="#ffcccc" valign="center"></td>
<td width=50 bgcolor="#cccccc"></td></tr>

  <tr><th>Col<td bgcolor="#ccffcc" align="center">b/p</td>
  <td></td>
  <td bgcolor="#ccffcc"></td></tr>
  <tr><th><td height=50 bgcolor="#cccccc"></td>
  <td bgcolor="#ffcccc"></td>
  <td bgcolor="#cccccc"></td></tr>
</table>
</td>

<td>

<table border=1>
  <tr><th><th></th><th>Row</th><th></th></tr>
  <tr><th><td width=100 height=100 bgcolor="#cccccc" align="center"
              valign="center">c-(ab/p)</td>
<td bgcolor="#ffcccc" valign="center">-a/p</td>
<td width=50 bgcolor="#cccccc"></td></tr>

  <tr><th>Col<td bgcolor="#ccffcc" align="center">b/p</td>
  <td></td>
  <td bgcolor="#ccffcc"></td></tr>
  <tr><th><td height=50 bgcolor="#cccccc"></td>
  <td bgcolor="#ffcccc"></td>
  <td bgcolor="#cccccc"></td></tr>
</table>

</td><td>

<table border=1>
  <tr><th><th></th><th>Row</th><th></th></tr>
  <tr><th><td width=100 height=100 bgcolor="#cccccc" align="center"
              valign="center">c-(ab/p)</td>
<td bgcolor="#ffcccc" valign="center">-a/p</td>
<td width=50 bgcolor="#cccccc"></td></tr>

  <tr><th>Col<td bgcolor="#ccffcc" align="center">b/p</td>
  <td>1/p</td>
  <td bgcolor="#ccffcc"></td></tr>
  <tr><th><td height=50 bgcolor="#cccccc"></td>
  <td bgcolor="#ffcccc"></td>
  <td bgcolor="#cccccc"></td></tr>
</table>

</td></tr></table>

</body>
</html>
